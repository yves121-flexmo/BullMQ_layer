# BullMQ Mail System - Architecture Unifi√©e

Ce projet fournit une **couche d'abstraction compl√®te** au-dessus de BullMQ pour cr√©er un syst√®me d'envoi de mails asynchrone robuste et scalable. L'architecture clarifie les concepts BullMQ et offre une interface simple pour g√©rer les queues, workers, √©v√©nements et workflows.

## üéØ Objectif

Simplifier l'utilisation de BullMQ en fournissant :
- Une interface unifi√©e pour tous les composants
- Une gestion automatique des schedulers et des √©v√©nements  
- Des patterns pr√™ts √† l'emploi pour les cas d'usage courants
- Une architecture modulaire et extensible
- Une gestion robuste des erreurs et des retries

## üèóÔ∏è Architecture

### Vue d'ensemble des composants

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   MailManager   ‚îÇ  ‚Üê Interface principale
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ         ‚îÇ
    ‚ñº         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Queue   ‚îÇ ‚îÇ Worker  ‚îÇ ‚îÇ Event   ‚îÇ ‚îÇ Flow    ‚îÇ
‚îÇManager  ‚îÇ ‚îÇManager  ‚îÇ ‚îÇManager  ‚îÇ ‚îÇManager  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üîß Composants Principaux

#### 1. **MailManager** (Interface principale)
- Point d'entr√©e unique pour toute l'application
- Unifie tous les autres managers
- Fournit des m√©thodes haut niveau simples
- G√®re l'initialisation et l'arr√™t propre

#### 2. **QueueManager** (Gestion des queues)
- Cr√©e et g√®re toutes les queues BullMQ
- **Cr√©√© automatiquement un scheduler pour chaque queue**
- G√®re les m√©triques et le nettoyage
- Operations : pause, resume, clean, obliterate

#### 3. **WorkerManager** (Gestion des workers)
- D√©marre et g√®re tous les workers
- Route les jobs vers les bons handlers
- G√®re la concurrence et les performances
- Fournit des handlers pr√©-d√©finis pour les emails

#### 4. **EventManager** (Syst√®me d'√©v√©nements)
- Centralise tous les √©v√©nements BullMQ
- Listeners globaux et sp√©cifiques par queue
- Monitoring et audit automatiques
- Alertes pour les √©checs r√©currents

#### 5. **FlowManager** (Workflows complexes)
- G√®re les workflows avec d√©pendances
- Patterns pr√©-d√©finis (email, newsletter, retry)
- Workflows conditionnels
- M√©triques et √©tat des flows

## üöÄ Installation

```bash
npm install bullmq ioredis dotenv
# S'assurer que Redis est install√© et en cours d'ex√©cution
brew install redis
brew services start redis
```

## üí° Utilisation

### Exemple basique

```javascript
const MailManager = require('./core/MailManager');
const WorkerManager = require('./core/WorkerManager');

async function basicUsage() {
  // Configuration
  const mailManager = new MailManager({
    redis: { host: 'localhost', port: 6379 },
    defaultOptions: {
      attempts: 3,
      backoff: { type: 'exponential', delay: 2000 }
    }
  });

  // Initialisation
  await mailManager.initialize();

  // 1. Cr√©ation d'une queue (avec scheduler automatique)
  mailManager.createQueue('emails');

  // 2. D√©marrage d'un worker
  const handlers = WorkerManager.createEmailHandlers();
  mailManager.startWorker('emails', handlers, { concurrency: 5 });

  // 3. Ajout de jobs
  await mailManager.addJob('emails', 'send-welcome', {
    to: 'user@example.com',
    subject: 'Bienvenue !'
  });

  // 4. Planification r√©currente
  await mailManager.scheduleJob(
    'emails', 
    'send-newsletter', 
    { to: 'subscribers@example.com' },
    '0 9 * * *' // Tous les jours √† 9h
  );

  // 5. Monitoring
  mailManager.onEvent('emails', 'completed', (data) => {
    console.log(`Email envoy√©: ${data.jobId}`);
  });

  // Nettoyage
  await mailManager.shutdown();
}
```

### Exemple avec workflows

```javascript
async function workflowUsage() {
  const mailManager = new MailManager({ redis: { host: 'localhost', port: 6379 } });
  await mailManager.initialize();

  mailManager.createQueue('email-processing');
  
  const handlers = {
    ...WorkerManager.createEmailHandlers(),
    ...FlowManager.createFlowHandlers()
  };
  
  mailManager.startWorker('email-processing', handlers);

  // Workflow d'email avec validation
  const emailFlow = await mailManager.addFlow({
    name: 'email-workflow',
    queueName: 'email-processing',
    data: { type: 'workflow' },
    children: [
      {
        name: 'validate-email',
        queueName: 'email-processing',
        data: { to: 'test@example.com' }
      },
      {
        name: 'prepare-template',
        queueName: 'email-processing',
        data: { template: 'welcome' },
        children: [
          {
            name: 'send-welcome',
            queueName: 'email-processing',
            data: { to: 'test@example.com' }
          }
        ]
      }
    ]
  });

  console.log('Workflow cr√©√©:', emailFlow.flowId);
}
```

## üìä Composants BullMQ Natifs vs Couche d'Abstraction

### üîç **BullMQ Natif** - Les 5 Composants Fondamentaux

BullMQ fournit 5 classes principales que vous devez g√©rer manuellement :

#### 1. **Queue** - Stockage des Jobs
```javascript
// BullMQ Natif
const { Queue } = require('bullmq');
const emailQueue = new Queue('emails', { connection: { host: 'localhost', port: 6379 } });

// Ajout de jobs
await emailQueue.add('send-welcome', { to: 'user@example.com' });
```
**Probl√®me** : Vous devez g√©rer manuellement la connexion Redis, la configuration, et chaque queue s√©par√©ment.

#### 2. **QueueScheduler** - Gestion des Jobs Diff√©r√©s/R√©currents ‚ö†Ô∏è OBSOL√àTE
```javascript
// BullMQ Ancien - QueueScheduler s√©par√© (ne plus utiliser)
const { QueueScheduler } = require('bullmq');
const scheduler = new QueueScheduler('emails', { connection: { host: 'localhost', port: 6379 } });

// ‚ùå OBSOL√àTE dans les versions r√©centes de BullMQ
```
**Probl√®me r√©solu** : QueueScheduler supprim√© dans BullMQ v5+, fonctionnalit√© int√©gr√©e dans Queue.

#### 3. **Worker** - Traitement des Jobs
```javascript
// BullMQ Natif
const { Worker } = require('bullmq');
const worker = new Worker('emails', async (job) => {
  if (job.name === 'send-welcome') {
    // Logique d'envoi
  } else if (job.name === 'send-newsletter') {
    // Autre logique
  }
  // Gestion manuelle de tous les types de jobs
}, { connection: { host: 'localhost', port: 6379 } });
```
**Probl√®me** : Code r√©p√©titif, gestion manuelle du routing des jobs.

#### 4. **QueueEvents** - Monitoring
```javascript
// BullMQ Natif
const { QueueEvents } = require('bullmq');
const events = new QueueEvents('emails', { connection: { host: 'localhost', port: 6379 } });

events.on('completed', ({ jobId }) => console.log(`Job ${jobId} termin√©`));
events.on('failed', ({ jobId }) => console.log(`Job ${jobId} √©chou√©`));
```
**Probl√®me** : Configuration r√©p√©titive pour chaque queue, pas de monitoring global.

#### 5. **FlowProducer** - Workflows Complexes
```javascript
// BullMQ Natif
const { FlowProducer } = require('bullmq');
const flow = new FlowProducer({ connection: { host: 'localhost', port: 6379 } });

// Configuration manuelle complexe
await flow.add({
  name: 'email-workflow',
  queueName: 'emails',
  data: {},
  children: [/* Configuration manuelle de chaque √©tape */]
});
```
**Probl√®me** : Configuration verbose, pas de patterns pr√©-d√©finis.

### üöÄ **Notre Couche d'Abstraction** - Tout Unifi√©

| Composant BullMQ | Probl√®me Natif | Notre Solution | Avantage |
|------------------|----------------|----------------|----------|
| **Queue** | Gestion manuelle s√©par√©e | `QueueManager` | ‚úÖ Cr√©ation centralis√©e, configuration partag√©e |
| **QueueScheduler** | Obsol√®te (int√©gr√©) | `QueueManager` | ‚úÖ **Fonctionnalit√© int√©gr√©e** dans Queue |
| **Worker** | Routing manuel des jobs | `WorkerManager` | ‚úÖ Handlers automatiques, routing intelligent |
| **QueueEvents** | Config r√©p√©titive | `EventManager` | ‚úÖ Listeners globaux + sp√©cifiques, monitoring unifi√© |
| **FlowProducer** | Configuration verbose | `FlowManager` | ‚úÖ Patterns pr√©-d√©finis, workflows simplifi√©s |

### üìã **Comparaison Concr√®te**

#### ‚ùå **BullMQ Natif** (15+ lignes, erreurs fr√©quentes)
```javascript
const { Queue, Worker, QueueEvents } = require('bullmq');

// 1. Configuration r√©p√©titive pour chaque composant
const connection = { host: 'localhost', port: 6379 };
const emailQueue = new Queue('emails', { connection });
// Note: QueueScheduler n'existe plus dans BullMQ v5+ (int√©gr√© dans Queue)
const events = new QueueEvents('emails', { connection });

// 2. Worker avec routing manuel
const worker = new Worker('emails', async (job) => {
  // Gestion manuelle de chaque type de job
  switch(job.name) {
    case 'send-welcome': /* logique */ break;
    case 'send-newsletter': /* logique */ break;
    default: throw new Error('Type de job inconnu');
  }
}, { connection });

// 3. Events s√©par√©s
events.on('completed', (data) => console.log('Job termin√©'));
events.on('failed', (data) => console.log('Job √©chou√©'));

// 4. Pas de nettoyage centralis√©
process.on('SIGTERM', async () => {
  await worker.close();
  await events.close();
  await emailQueue.close();
});
```

#### ‚úÖ **Notre Architecture** (3 lignes, z√©ro erreur)
```javascript
const MailManager = require('./core/MailManager');

// 1. Initialisation unifi√©e
const mailManager = new MailManager({ redis: { host: 'localhost', port: 6379 } });
await mailManager.initialize();

// 2. Cr√©ation queue + scheduler automatique + events
mailManager.createQueue('emails');

// 3. Worker avec handlers pr√©-d√©finis
const handlers = WorkerManager.createEmailHandlers();
mailManager.startWorker('emails', handlers);

// 4. Nettoyage automatique
await mailManager.shutdown(); // Ferme TOUT proprement
```

### üß† **Correspondance 1:1 des Concepts**

```
BullMQ Natif (Complexe)          Notre Couche (Simple)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Queue               ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ QueueManager        ‚îÇ
‚îÇ + Scheduler int√©gr√© ‚îÇ         ‚îÇ (gestion unifi√©e)   ‚îÇ
‚îÇ + Redis Config      ‚îÇ         ‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Worker              ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ WorkerManager       ‚îÇ
‚îÇ + Job Routing       ‚îÇ         ‚îÇ (routing auto)      ‚îÇ
‚îÇ + Error Handling    ‚îÇ         ‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ QueueEvents         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ EventManager        ‚îÇ
‚îÇ + Event Listeners   ‚îÇ         ‚îÇ (global + local)    ‚îÇ
‚îÇ + Per-Queue Config  ‚îÇ         ‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FlowProducer        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ FlowManager         ‚îÇ
‚îÇ + Manual Config     ‚îÇ         ‚îÇ (patterns ready)    ‚îÇ
‚îÇ + Complex Setup     ‚îÇ         ‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

         Tout g√©r√© par MailManager (Interface unique)
```

### ‚ùó **Points Critiques BullMQ que Notre Architecture R√©sout**

1. **Scheduler Obsol√®te** ‚ûú **Int√©gr√© dans Queue** (BullMQ v5+)
2. **Configuration Redis R√©p√©t√©e** ‚ûú **Configuration centralis√©e** 
3. **Gestion d'Erreurs Manuelle** ‚ûú **Retry intelligent** int√©gr√©
4. **Monitoring Fragment√©** ‚ûú **Monitoring unifi√©** 
5. **Shutdown Complexe** ‚ûú **Shutdown automatique** de tous les composants

**Notre couche n'invente rien** - elle organise simplement BullMQ de fa√ßon logique et supprime la complexit√© inutile !

## üîÑ Patterns Disponibles

### Jobs simples
```javascript
await mailManager.addJob('emails', 'send-welcome', data);
```

### Jobs planifi√©s (avec scheduler automatique)
```javascript
await mailManager.scheduleJob('emails', 'send-newsletter', data, '0 9 * * *');
```

### Workflows avec d√©pendances
```javascript
await mailManager.addFlow(flowDefinition);
```

### Handlers d'emails pr√©-d√©finis
- `send-welcome` : Email de bienvenue
- `send-newsletter` : Newsletter
- `send-reset-password` : R√©initialisation mot de passe
- `send-notification` : Notifications

### Flows pr√©-d√©finis
- `createEmailFlow()` : Email avec validation
- `createNewsletterFlow()` : Newsletter multi-destinataires  
- `createConditionalFlow()` : Workflow conditionnel
- `createRetryFlow()` : Retry intelligent

## üìà Monitoring et M√©triques

```javascript
// √âtat de sant√© global
const health = await mailManager.healthCheck();

// Statistiques d'une queue
const stats = await mailManager.getQueueStats('emails');

// M√©triques compl√®tes
const allMetrics = await mailManager.queueManager.getAllQueueMetrics();
const flowMetrics = mailManager.flowManager.getFlowMetrics();
const eventStats = mailManager.eventManager.getEventStats();

// Audit log
mailManager.eventManager.setupAuditListeners();
const auditLog = mailManager.eventManager.getAuditLog(100);
```

## üõ†Ô∏è Configuration Avanc√©e

```javascript
const config = {
  redis: {
    host: 'localhost',
    port: 6379,
    // Ou utiliser une URL : url: 'redis://localhost:6379'
  },
  defaultOptions: {
    attempts: 5,
    backoff: { type: 'exponential', delay: 2000 },
    removeOnComplete: 100,
    removeOnFail: 50
  }
};

const mailManager = new MailManager(config);
```

## üîç Handlers Personnalis√©s

```javascript
const customHandlers = {
  'my-custom-job': async (data, job) => {
    console.log(`Traitement custom: ${data.id}`);
    
    // Mise √† jour du progr√®s
    await job.updateProgress(50);
    
    // Logique m√©tier
    const result = await processData(data);
    
    await job.updateProgress(100);
    return result;
  }
};

mailManager.startWorker('my-queue', customHandlers);
```

## üìÅ Structure du Projet

```
bullMQ_examples/
‚îú‚îÄ‚îÄ core/                    # Architecture principale
‚îÇ   ‚îú‚îÄ‚îÄ MailManager.js      # Interface unifi√©e
‚îÇ   ‚îú‚îÄ‚îÄ QueueManager.js     # Gestion queues + schedulers
‚îÇ   ‚îú‚îÄ‚îÄ WorkerManager.js    # Gestion workers + handlers
‚îÇ   ‚îú‚îÄ‚îÄ EventManager.js     # Syst√®me d'√©v√©nements
‚îÇ   ‚îî‚îÄ‚îÄ FlowManager.js      # Workflows complexes
‚îú‚îÄ‚îÄ examples/               # Exemples d'utilisation
‚îÇ   ‚îî‚îÄ‚îÄ basic-usage.js      # Exemples complets
‚îú‚îÄ‚îÄ scheduler.js            # Exemple de planification
‚îî‚îÄ‚îÄ main.js                 # Interface Bull Board
```

## üß™ Tests et Exemples

```bash
# Exemple basique
node examples/basic-usage.js

# Scheduler
node scheduler.js

# Interface de monitoring
node main.js  # http://localhost:3000
```

## ‚ö° Performances

- **Concurrence configurable** par worker
- **Nettoyage automatique** des anciens jobs
- **Retry exponentiel** intelligent
- **Monitoring des performances** int√©gr√©
- **Audit log** avec rotation automatique

## üîê Gestion d'Erreurs

- Retries automatiques avec backoff exponentiel
- Monitoring des √©checs r√©currents
- Alertes pour les jobs probl√©matiques
- Isolation des erreurs par queue
- Logs d√©taill√©s pour le debug

## üì¶ Migration depuis BullMQ Classique

```javascript
// Avant (BullMQ classique)
const { Queue, Worker, QueueScheduler } = require('bullmq');
const queue = new Queue('emails');
const scheduler = new QueueScheduler('emails');
const worker = new Worker('emails', processor);

// Apr√®s (Architecture unifi√©e)
const mailManager = new MailManager();
await mailManager.initialize();
mailManager.createQueue('emails');  // Scheduler cr√©√© automatiquement
mailManager.startWorker('emails', handlers);
```

## üè¢ Cas d'Usage Sp√©cialis√© : Syst√®me de Rappels de Remboursements

### Architecture pour Rappels Automatiques

Le projet inclut `RemboursementMailManager`, une sp√©cialisation du MailManager pour g√©rer automatiquement les rappels de remboursements selon vos sp√©cifications :

#### üìÖ **Planification Automatique**

```javascript
const RemboursementMailManager = require('./core/RemboursementMailManager');

const reminderManager = new RemboursementMailManager({
  redis: { host: 'localhost', port: 6379 },
  reimbursementService: yourReimbursementService,
  managerService: yourManagerService,
  emailService: yourEmailService
});

await reminderManager.initializeReminderSystem();
// Le syst√®me fonctionne maintenant automatiquement !
```

#### üè¢ **Corporate (SALARY) - Logique Impl√©ment√©e**
- **Cron** : `0 9 1-10 * *` (Jours 1-10 du mois √† 9h)
- **Types** : Remboursements SALARY avec statut PENDING/OVERDUE
- **Logique** :
  - `dueDate <= aujourd'hui` ‚Üí Email "paiement en retard" 
  - `dueDate > aujourd'hui` ‚Üí Email "rappel avant √©ch√©ance"
- **Destinataires** : Owner + 3 plus vieux managers Corporate

#### üè• **Coverage (TREASURY) - Logique Impl√©ment√©e**
- **Cron** : `0 10 * * *` (Tous les jours √† 10h)
- **Types** : Remboursements TREASURY avec statut PENDING/OVERDUE
- **Organisation** : Group√©s par health-coverage comme demand√©
- **Logique** :
  - `dueDate <= aujourd'hui` ‚Üí Email "paiement en retard"
  - `dueDate <= aujourd'hui + 10 jours` ‚Üí Email "rappel 10 jours avant"
  - Sinon ‚Üí Pas d'email
- **Destinataires** : Owner + 3 plus vieux managers Coverage

#### üîß **Services √† Impl√©menter**

```javascript
const config = {
  redis: { host: 'localhost', port: 6379 },
  reimbursementService: {
    async getReimbursements({ type, statuses }) {
      // Retourner les remboursements selon type (SALARY/TREASURY) et statuts
      return await Reimbursement.find({ 
        type, 
        globalStatus: { $in: statuses } 
      });
    }
  },
  managerService: {
    async getReimbursementOwner(reimbursementId) {
      // Retourner le propri√©taire du remboursement
      return await Manager.findOne({ reimbursementId });
    },
    async getOldestManagers(type, limit = 3) {
      // Retourner les 3 plus vieux managers selon le type
      return await Manager.find({ type })
        .sort({ createdAt: 1 })
        .limit(limit);
    }
  },
  emailService: {
    async sendReminderEmail({ type, recipients, reimbursement, daysInfo, template }) {
      // Envoyer l'email via votre service (SendGrid, Mailgun, etc.)
      return await sendEmail({
        to: recipients.map(r => r.email),
        subject: template.subject,
        template: template.template,
        data: { reimbursement, daysInfo }
      });
    }
  }
};
```

#### üìä **Monitoring et Contr√¥le**

```javascript
// Statistiques en temps r√©el
const stats = await reminderManager.getReminderStats();

// Ex√©cution forc√©e pour tests
await reminderManager.forceReminderExecution('corporate'); // ou 'coverage' ou 'both'

// Monitoring des erreurs
reminderManager.onEvent('corporate-reminders', 'failed', (data) => {
  console.error('Erreur Corporate:', data.failedReason);
  // Alerter les administrateurs
});
```

#### üß™ **Test du Syst√®me**

```bash
# Test avec donn√©es mock
node examples/remboursement-usage.js

# Test du monitoring
node examples/remboursement-usage.js monitoring

# Configuration production
node examples/remboursement-usage.js production
```

## üöÄ Int√©gration dans une Application Existante

1. **Copier le dossier `core/`** dans votre projet
2. **Installer les d√©pendances** : `npm install bullmq ioredis`
3. **Initialiser MailManager** dans votre application
4. **Remplacer les appels BullMQ** par l'interface MailManager
5. **Configurer les handlers** pour vos types d'emails
6. **Pour les rappels** : Utiliser `RemboursementMailManager` avec vos services

## üìã API R√©f√©rence

### MailManager

```javascript
// Initialisation
await mailManager.initialize()
await mailManager.shutdown()

// Queues
mailManager.createQueue(name, options)
await mailManager.addJob(queueName, jobName, data, options)
await mailManager.scheduleJob(queueName, jobName, data, cronPattern, options)

// Workers
mailManager.startWorker(queueName, handlers, options)

// Flows
await mailManager.addFlow(flowDefinition)

// Events
mailManager.onEvent(queueName, eventType, callback)

// Monitoring
await mailManager.getQueueStats(queueName)
await mailManager.healthCheck()
```

## üìÑ Licence

ISC

---

**üí° Cette architecture r√©sout la confusion entre les concepts BullMQ en fournissant une interface claire et unifi√©e. Plus besoin de g√©rer manuellement schedulers, events et workers !**
